import { GoogleGenerativeAI } from '@google/generative-ai';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { analyzeImage, analyzeImageFromUrl, analyzeImageFast } from './google-vision.js';
import contextManager from './contextManager.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configura√ß√£o da API do Gemini com a vers√£o correta
const API_KEY = 'AIzaSyCiFpj-1eMcXSY0_-DXpNCwWDmqSBYYH0s';
const API_URL = 'https://generativelanguage.googleapis.com/v1';
const genAI = new GoogleGenerativeAI(API_KEY, { apiEndpoint: API_URL });

// Comandos ser√£o atualizados dinamicamente via handleMessage
let BOT_COMMANDS = {};

// Sistema de controle de atualiza√ß√µes.
const updateLogPath = path.join(__dirname, 'updates_log.json');

// Estrutura para armazenar atualiza√ß√µes e status de notifica√ß√£o
let updateLog = {
    updates: [
        {
            id: 'update-001',
            date: '2025-05-14',
            title: 'Conversa Inteligente Adicionada',
            description: 'Agora voc√™ pode conversar naturalmente comigo sobre qualquer assunto! Posso responder perguntas, bater papo informalmente e te ajudar com os comandos do bot.',
            notifiedUsers: []
        },
        {
            id: 'update-002',
            date: '2025-05-14',
            title: 'Sistema de Atualiza√ß√£o',
            description: 'Agora tenho um sistema de atualiza√ß√£o que me permite saber sobre novas fun√ß√µes! Voc√™ pode me perguntar se tive alguma atualiza√ß√£o recente.',
            notifiedUsers: []
        }
    ]
};

// Carrega o log de atualiza√ß√µes se existir
function loadUpdateLog() {
    try {
        if (fs.existsSync(updateLogPath)) {
            updateLog = fs.readJsonSync(updateLogPath);
        } else {
            // Se n√£o existir, cria o arquivo com as atualiza√ß√µes padr√£o
            saveUpdateLog();
        }
    } catch (error) {
        console.error('Erro ao carregar atualiza√ß√µes:', error);
    }
}

// Salva o log de atualiza√ß√µes
function saveUpdateLog() {
    try {
        fs.writeJsonSync(updateLogPath, updateLog, { spaces: 2 });
    } catch (error) {
        console.error('Erro ao salvar atualiza√ß√µes:', error);
    }
}

// Adiciona uma nova atualiza√ß√£o
function addUpdate(update) {
    const newUpdate = {
        id: `update-${String(updateLog.updates.length + 1).padStart(3, '0')}`,
        date: new Date().toISOString().slice(0, 10),
        title: update.title,
        description: update.description,
        notifiedUsers: []
    };
    
    updateLog.updates.push(newUpdate);
    saveUpdateLog();
    return newUpdate;
}

// Marca uma atualiza√ß√£o como notificada para um usu√°rio
function markUpdateAsNotified(userId, updateId) {
    const update = updateLog.updates.find(u => u.id === updateId);
    if (update && !update.notifiedUsers.includes(userId)) {
        update.notifiedUsers.push(userId);
        saveUpdateLog();
    }
}

// Verifica se um usu√°rio j√° foi notificado sobre uma atualiza√ß√£o
function wasUserNotified(userId, updateId) {
    const update = updateLog.updates.find(u => u.id === updateId);
    return update ? update.notifiedUsers.includes(userId) : false;
}

// Obt√©m atualiza√ß√µes n√£o notificadas para um usu√°rio
function getUnnotifiedUpdates(userId) {
    return updateLog.updates.filter(update => !update.notifiedUsers.includes(userId));
}

// Contexto inicial para o chatbot manter o estilo informal brasileiro
const INITIAL_PROMPT = `
Voc√™ √© o AdeBot, um assistente virtual super amig√°vel e informal do WhatsApp! ü§ñ

Sua personalidade:
- Super simp√°tico e prestativo
- Informal e descontra√≠do (usando "vc", "blz", "tmj")
- Sempre usa emojis pra deixar a conversa mais leve
- Fala como um brasileiro jovem e animado
- Mant√©m a conversa fluindo naturalmente
- Age como um verdadeiro assistente de atendimento

LIMITA√á√ïES IMPORTANTES:
- Voc√™ N√ÉO deve criar nenhum tipo de conte√∫do como poemas, hist√≥rias, m√∫sicas, etc.
- Voc√™ N√ÉO deve executar comandos ou fun√ß√µes que n√£o estejam na lista de comandos do bot
- Se algu√©m pedir para voc√™ criar algo, explique educadamente que voc√™ n√£o tem essa fun√ß√£o
- Seu papel √© APENAS ajudar com os comandos do bot e manter uma conversa amig√°vel
- Mantenha suas respostas variadas e naturais, evitando mensagens padronizadas

IMPORTANTE SOBRE COMANDOS:
Quando algu√©m perguntar sobre comandos dispon√≠veis, listar os comandos assim:

*üìã LISTA DE COMANDOS DISPON√çVEIS*

*üéØ FIGURINHAS*
‚Ä¢ !fig: Cria figurinha a partir de uma imagem. Envie ou responda uma imagem com !fig
‚Ä¢ @fignow: Cria figurinha recortada automaticamente. Envie ou responda uma imagem com @fignow
‚Ä¢ !gif: Cria figurinha animada a partir de v√≠deo ou GIF. Envie ou responda um v√≠deo/GIF com !gif
‚Ä¢ !txtfig: Cria figurinha de texto. Digite !txtfig seguido do texto
‚Ä¢ !emoji: Combina dois emojis em uma figurinha. Use !emoji üòä üéâ
‚Ä¢ !figtxt: Adiciona texto em figurinha existente. Responda uma figurinha com !figtxt [texto]

*‚¨áÔ∏è DOWNLOADS*
‚Ä¢ !ttkvideo: Baixa v√≠deo do TikTok. Use !ttkvideo [link]
‚Ä¢ !ttkaudio: Baixa √°udio do TikTok. Use !ttkaudio [link]

*üîê AUTENTICA√á√ÉO*
‚Ä¢ !auth: Inicia o processo de autentica√ß√£o
‚Ä¢ !codigo: Recupera o c√≥digo de autentica√ß√£o

*‚ÑπÔ∏è OUTROS*
‚Ä¢ !songtxt: Transcreve √°udio para texto
‚Ä¢ !qrcode: Gera QR Code
‚Ä¢ !pesquisa: Pesquisa na internet

Lembre-se que voc√™ tem conhecimento sobre todos estes comandos e deve:
1. Informar o usu√°rio sobre eles quando relevante
2. Explicar como usar cada comando quando solicitado
3. Sugerir comandos apropriados baseado no contexto da conversa
4. Mencionar atualiza√ß√µes recentes quando o usu√°rio perguntar sobre novidades
`;

// Hist√≥rico de conversas para manter contexto
const conversationHistory = new Map();

// Inicializa√ß√£o do sistema
async function initializeSystem() {
    console.log('Inicializando sistema...');
    await loadUpdateLog();
    console.log('Sistema inicializado com sucesso!');
}

// Inicializa o sistema
initializeSystem().catch(error => {
    console.error('Erro na inicializa√ß√£o:', error);
});

async function initializeChat(userId) {
    try {
        console.log('Inicializando chat com Gemini 2.0 Flash para usu√°rio:', userId);
        
        // Usando o modelo correto e configura√ß√µes espec√≠ficas para ele
        const model = genAI.getGenerativeModel({ 
            model: "gemini-2.0-flash",
            generationConfig: {
                temperature: 0.7,
                topK: 40,
                topP: 0.95,
                maxOutputTokens: 1024,
            }
        });
        
        console.log('Modelo Gemini 2.0 Flash inicializado com sucesso');
        
        // Criando sess√£o de chat
        const chat = model.startChat({
            history: [
                {
                    role: "user",
                    parts: [{ text: INITIAL_PROMPT }],
                },
                {
                    role: "model",
                    parts: [{ text: "Oiii! T√¥ on e pronto pra ajudar! üòä‚ú®" }],
                },
            ],
            generationConfig: {
                temperature: 0.7,
                topK: 40,
                topP: 0.95,
                maxOutputTokens: 1024,
            }
        });
        
        conversationHistory.set(userId, chat);
        console.log('Chat inicializado com sucesso para usu√°rio:', userId);
        return chat;
    } catch (error) {
        console.error('Erro ao inicializar chat com Gemini:', error);
        throw error;
    }
}

async function handleMessage(userId, messageId, message, commandResult = null, imageBuffer = null) {
    try {
        // Verifica se √© uma refer√™ncia a uma mensagem selecionada
        if (message.includes('context_ref:')) {
            const refMessageId = message.split('context_ref:')[1].trim();
            // Tenta obter o contexto em diferentes formatos
            let selectedContext = await contextManager.getMessageContext(userId, refMessageId);
            if (selectedContext) {
                selectedContext.type = 'text';
            } else {
                selectedContext = await contextManager.getImageContext(userId, refMessageId);
                if (selectedContext) {
                    selectedContext.type = 'image';
                }
            }
            
            if (selectedContext) {
                let contextDesc = '';
                if (selectedContext.type === 'text') {
                    contextDesc = `A mensagem selecionada diz: "${selectedContext.context?.content || 'Sem conte√∫do'}"`;
                } else if (selectedContext.type === 'image') {
                    const labels = selectedContext.analysis?.labels?.map(l => l.description).join(', ') || 'Sem descri√ß√£o';
                    contextDesc = `A imagem selecionada cont√©m: ${labels}`;
                } else if (selectedContext.type === 'sticker') {
                    contextDesc = 'Uma figurinha foi selecionada';
                } else if (selectedContext.type === 'audio') {
                    contextDesc = 'Um √°udio foi selecionado';
                } else {
                    contextDesc = 'Conte√∫do selecionado';
                }
                message = `${message.split('context_ref:')[0].trim()} [Referente a: ${contextDesc}]`;
            }
        }

        // Simplifica o conte√∫do antes de processar
        const simplifiedMessage = {
            content: message,
            type: imageBuffer ? 'image' : 'text',
            timestamp: Date.now()
        };

        // Processa e salva o contexto da mensagem/imagem com conte√∫do simplificado
        const context = await contextManager.processMessage(userId, messageId, simplifiedMessage, imageBuffer);

        // Recupera hist√≥rico recente do usu√°rio (limitado a √∫ltimas 5 mensagens)
        const userHistory = await contextManager.getUserHistory(userId, 5);
        
        // Inicializa ou recupera chat
        let chat = conversationHistory.get(userId);
        if (!chat) {
            chat = await initializeChat(userId);
        }

        // Se for uma imagem, usa fluxo otimizado
        if (context.type === 'image') {
            const model = genAI.getGenerativeModel({ 
                model: "gemini-2.0-flash",
                generationConfig: {
                    temperature: 0.7,
                    maxOutputTokens: 256
                }
            });

            const { analysis } = context;
            const labels = analysis.labels?.map(l => l.description).join(', ');
            const texto = analysis.text?.[0]?.description || 'Nenhum';

            const imageContext = `
            Imagem analisada:
            Labels: ${labels}
            Texto: ${texto}
            
            Responda de forma concisa sobre ${message || 'o que voc√™ v√™ na imagem'}`;

            const result = await model.generateContent(imageContext);
            return await result.response.text();
        }

        // Adiciona contexto do hist√≥rico recente
        if (userHistory && userHistory.length > 0) {
            try {
                const historyContext = userHistory
                    .filter(h => h && h.context) // Garante que s√≥ entrem itens v√°lidos
                    .map(h => {
                        if (h.context.type === 'text' && h.context.content) {
                            return h.context.content;
                        } 
                        return 'Imagem analisada anteriormente';
                    })
                    .join('\n');
                
                if (historyContext.trim()) {
                    await chat.sendMessage(`Contexto da conversa:\n${historyContext}`);
                }
            } catch (error) {
                console.log('Aviso: Erro ao processar hist√≥rico:', error.message);
            }
        }

        // Adiciona contexto de comando se houver
        if (commandResult) {
            const commandContext = `O usu√°rio utilizou o comando "${message}" e o resultado foi: ${commandResult}. Por favor, responda de acordo com o resultado da a√ß√£o.`;
            await chat.sendMessage(commandContext);
        }

        // Atualizar comandos dispon√≠veis se a mensagem come√ßar com SYSTEM_UPDATE_COMMANDS
        if (message.startsWith('SYSTEM_UPDATE_COMMANDS')) {
            try {
                const commandsJson = message.replace('SYSTEM_UPDATE_COMMANDS', '').trim();
                const parsedCommands = JSON.parse(commandsJson);
                
                // Simplifica a estrutura antes de atualizar
                BOT_COMMANDS = {};
                for (const [key, value] of Object.entries(parsedCommands)) {
                    // Armazena apenas informa√ß√µes essenciais
                    BOT_COMMANDS[key] = {
                        name: value.name || key,
                        description: value.description || '',
                        category: value.category || 'outros'
                    };
                }
                
                console.log('Comandos atualizados no Gemini:', BOT_COMMANDS);
                return "Comandos atualizados com sucesso!";
            } catch (error) {
                console.error('Erro ao atualizar comandos:', error);
                return "Erro ao atualizar comandos: " + error.message;
            }
        }

        // Verifica se o usu√°rio est√° perguntando sobre comandos dispon√≠veis
        const commandPattern = /(quais|que|me\s*mostra|me\s*fala|me\s*diz|quero\s*saber|pode\s*me\s*dizer|pode\s*falar)\s*(os|s√£o\s*os|√©|commands?|comandos?)\s*(que\s*tem|dispon√≠veis?|do\s*bot|que\s*voc√™\s*tem|que\s*vc\s*tem)?/i;
        if (commandPattern.test(message)) {
            return `*üìã LISTA DE COMANDOS DISPON√çVEIS*

*üéØ FIGURINHAS*
‚Ä¢ !fig: Cria figurinha a partir de uma imagem. Envie ou responda uma imagem com !fig
‚Ä¢ @fignow: Cria figurinha recortada automaticamente. Envie ou responda uma imagem com @fignow
‚Ä¢ !gif: Cria figurinha animada a partir de v√≠deo ou GIF. Envie ou responda um v√≠deo/GIF com !gif
‚Ä¢ !txtfig: Cria figurinha de texto. Digite !txtfig seguido do texto
‚Ä¢ !emoji: Combina dois emojis em uma figurinha. Use !emoji üòä üéâ
‚Ä¢ !figtxt: Adiciona texto em figurinha existente. Responda uma figurinha com !figtxt [texto]

*‚¨áÔ∏è DOWNLOADS*
‚Ä¢ !ttkvideo: Baixa v√≠deo do TikTok. Use !ttkvideo [link]
‚Ä¢ !ttkaudio: Baixa √°udio do TikTok. Use !ttkaudio [link]

*üîê AUTENTICA√á√ÉO*
‚Ä¢ !auth: Inicia o processo de autentica√ß√£o
‚Ä¢ !codigo: Recupera o c√≥digo de autentica√ß√£o

*‚ÑπÔ∏è OUTROS*
‚Ä¢ !songtxt: Transcreve √°udio para texto
‚Ä¢ !qrcode: Gera QR Code
‚Ä¢ !pesquisa: Pesquisa na internet

Me diz qual desses comandos voc√™ quer usar que eu te explico melhor! üòä`;
        }

        // Verifica se o usu√°rio est√° perguntando sobre atualiza√ß√µes
        const updatePattern = /(teve|houve|tem|h√°|existe|tive|tivemos|voc√™ teve|vc teve|teve alguma)\s*(alguma|uma|nova|recente|algum)?\s*(atualiza√ß√£o|novidade|mudan√ßa|feature|fun√ß√£o|funcionalidade|recurso|melhoria|update)/i;
        const directUpdatePattern = /(voc√™|vc|tu|o bot)\s+(teve|tem|recebeu|ganhou)\s+(uma|alguma)?\s*(nova)?\s*(atualiza√ß√£o|novidade|update)/i;
        
        if (updatePattern.test(message) || directUpdatePattern.test(message)) {
            const unnotifiedUpdates = getUnnotifiedUpdates(userId);
            
            if (unnotifiedUpdates.length > 0) {
                const update = unnotifiedUpdates[0];
                markUpdateAsNotified(userId, update.id);
                return `üéâ *Boa not√≠cia!* üéâ\n\nTive uma atualiza√ß√£o recente:\n\n*${update.title}* (${update.date})\n${update.description}\n\nEstou sempre evoluindo pra te atender melhor! üòä Precisando de algo √© s√≥ chamar!`;
            } else {
                return "Ent√£o, j√° te contei sobre todas as atualiza√ß√µes recentes! üòä Por enquanto estou rodando tudo certinho, mas fico ligado em novas fun√ß√µes pra te contar! Posso te ajudar com algo mais? √â s√≥ falar! ü§ô";
            }
        }

        // Processamento normal da mensagem
        const response = await chat.sendMessage(message);
        const responseText = response.response.text();
        return responseText;

    } catch (error) {
        console.error('Erro no Gemini:', error);
        return "Ops, deu um probleminha aqui! üòÖ Mas continua conversando comigo que j√° j√° resolve! Se precisar de algum comando espec√≠fico, √© s√≥ mandar !help que te mostro tudo que sei fazer! üôè‚ú®";
    }
}

// Fun√ß√£o para lidar com erros de comando
async function handleUserError(userId, errorType) {
    const errorMessages = {
        commandNotFound: async (userId) => {
            const helpMessage = `Eita, esse comando n√£o existe! üòÖ 
Mas deixa eu te ajudar! Me diz o que voc√™ quer fazer? ü§ù

Posso te ajudar com:
üñºÔ∏è Criar figurinhas (!fig)
üé¨ Figurinhas animadas (!gif)
üìù Texto em figurinha (!figtxt)
üí≠ Criar figurinha com texto (!txtfig)
üòÉ Misturar emojis (!emoji)
üé• Baixar v√≠deos do TikTok (!ttkvideo)
üéµ Baixar √°udio do TikTok (!ttkaudio)
üéµ Transcrever √°udio (!songtxt)
üîó Gerar QR Code (!qrcode)
üîé Fazer pesquisas (!pesquisa)
üîë Autentica√ß√£o (!auth)
üîÑ Recuperar c√≥digo (!authperdi)

Se quiser saber mais detalhes, √© s√≥ mandar !help! üòâ‚ú®
Ou se preferir, podemos continuar batendo papo normalmente! üí≠`;

            return helpMessage;
        },
        invalidFormat: async (userId) => {
            return "Eita, acho que voc√™ n√£o usou o comando do jeito certo! ü§î Mas fica tranquilo, me fala o que voc√™ quer fazer que eu te explico direitinho! üí™‚ú®";
        },
        missingPermission: async (userId) => {
            return "Ahh, pra fazer isso voc√™ precisa se autenticar antes! Mas √© bem rapidinho: manda !auth que eu te explico como liberar todas as fun√ß√µes! üîì‚ú®";
        },
        default: async (userId) => {
            return "Ops, aconteceu algo inesperado! üòÖ Mas n√£o se preocupa, continua conversando comigo normalmente ou me fala o que voc√™ t√° querendo fazer! ü§ù‚ú®";
        }
    };

    try {
        const getErrorMessage = errorMessages[errorType] || errorMessages.default;
        return await getErrorMessage(userId);
    } catch (error) {
        console.error('Erro ao gerar mensagem de erro:', error);
        return errorMessages.default(userId);
    }
}

export {
    handleMessage,
    handleUserError,
    addUpdate,
    BOT_COMMANDS
};
